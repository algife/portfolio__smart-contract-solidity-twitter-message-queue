// const detectEthereumProvider = require("@metamask/detect-provider");
// const Web3 = require("web3");
const Contract = require("web3-eth-contract");

// Contract.setProvider('ws://localhost:8546'); // set provider for all later instances to use
require("dotenv").config();

// ------
const { CONTRACT_ADDRESS, OWNER_ADDRESS } = process.env;

// DOCS: https://web3js.readthedocs.io/en/v1.2.11/web3-eth-contract.html

const web3 = new Web3(window.ethereum);
const contract = new web3.eth.Contract(abi, CONTRACT_ADDRESS, {
  from: CONTRACT_ADDRESS, // default from address
  // gasPrice: '20000000000' // default gas price in wei, 20 gwei in this case
});

main();

function main() {
  startListening();
}

function pingContract() {
  contract.methods
    .isPaused()
    .send()
    .then(console.log)
    .on("receipt", function () {
      console.log("[RECEIPT EVENT]");
    });
}

async function onConnectWalletClicked() {
  if (window.ethereum) {
    // Request Wallet Connection from Metamask
    // TODO: ANSWER can be found here: https://docs.metamask.io/wallet/get-started/set-up-dev-environment/
    // const accounts = YOUR CODE

    setConnected(accounts[0]);
  } else {
    console.error("No web3 provider detected");
    document.getElementById("connectMessage").innerText =
      "No web3 provider detected. Please install MetaMask.";
  }
}

async function createTweet(content) {
  const accounts = await web3.eth.getAccounts();
  try {
    // Call the contract createTweet method in order to crete the actual TWEET
    // HINT: https://web3js.readthedocs.io/en/v1.2.11/web3-eth-contract.html#methods-mymethod-send
    const message = "this is my tweet created from the DApp";
    const createdTweet = await contract.methods.createTweet(message).send();
    console.log(createdTweet);

    // GOAL: reload tweets after creating a new tweet
    displayTweets(accounts[0]);
  } catch (error) {
    console.error("User rejected request:", error);
  }
}

async function displayTweets(userAddress) {
  const tweetsContainer = document.getElementById("tweetsContainer");
  let tempTweets = [];
  tweetsContainer.innerHTML = "";
  // Call the function getAllTweets from smart contract to get all the tweets
  tempTweets = await contract.methods
    .getAllTweets({ author: OWNER_ADDRESS })
    .send();
  console.log(tempTweets);

  // we do this so we can sort the tweets  by timestamp
  const tweets = [...tempTweets];
  tweets.sort((a, b) => b.timestamp - a.timestamp);
  for (let i = 0; i < tweets.length; i++) {
    const tweetElement = document.createElement("div");
    tweetElement.className = "tweet";

    const userIcon = document.createElement("img");
    userIcon.className = "user-icon";
    userIcon.src = `https://avatars.dicebear.com/api/human/${tweets[i].author}.svg`;
    userIcon.alt = "User Icon";

    tweetElement.appendChild(userIcon);

    const tweetInner = document.createElement("div");
    tweetInner.className = "tweet-inner";

    tweetInner.innerHTML += `
        <div class="author">${shortAddress(tweets[i].author)}</div>
        <div class="content">${tweets[i].text}</div>
    `;

    const likeButton = document.createElement("button");
    likeButton.className = "like-button";
    likeButton.innerHTML = `
        <i class="far fa-heart"></i>
        <span class="likes-count">${tweets[i].likes}</span>
    `;
    likeButton.setAttribute("data-id", tweets[i].id);
    likeButton.setAttribute("data-author", tweets[i].author);

    addLikeButtonListener(
      likeButton,
      userAddress,
      tweets[i].id,
      tweets[i].author
    );
    tweetInner.appendChild(likeButton);
    tweetElement.appendChild(tweetInner);
    tweetsContainer.appendChild(tweetElement);
  }
}

function addLikeButtonListener(likeButton, address, id, author) {
  likeButton.addEventListener("click", async (e) => {
    e.preventDefault();

    e.currentTarget.innerHTML = '<div class="spinner"></div>';
    e.currentTarget.disabled = true;
    try {
      await likeTweet(author, id);
      displayTweets(address);
    } catch (error) {
      console.error("Error liking tweet:", error);
    }
  });
}

function shortAddress(address, startLength = 6, endLength = 4) {
  return `${address.slice(0, startLength)}...${address.slice(-endLength)}`;
}

async function likeTweet(author, id) {
  try {
    // Call the likeTweet function from smart contract
    const likedTweet = await contract.methods.likeTweet(author, id).send();
    console.log(likedTweet);
  } catch (error) {
    console.error("User rejected request:", error);
  }
}

function setConnected(address) {
  document.getElementById("userAddress").innerText =
    "Connected: " + shortAddress(address);
  document.getElementById("connectMessage").style.display = "none";
  document.getElementById("tweetForm").style.display = "block";

  // GOAL: display all tweets after connecting to metamask
  displayTweets(address);
}

const getHtmlElements = () => ({
  connectWalletBtn: document.getElementById("connectWalletBtn"),
  tweetFormForm: document.getElementById("tweetForm"),
  ethereumButton: document.querySelector(".enableEthereumButton"),
  userAddress: document.getElementById("userAddress"),
});

async function startListening() {
  const provider = await detectEthereumProvider();
  if (provider) {
    initializeApp(provider);
  } else {
    console.log("Please install MetaMask!");
  }
}

function onEthBtnClicked() {
  getAccount();
}

async function onTweetFormSubmitted(e) {
  e.preventDefault();
  const content = document.getElementById("tweetContent").value;
  const tweetSubmitButton = document.getElementById("tweetSubmitBtn");
  tweetSubmitButton.innerHTML = '<div class="spinner"></div>';
  tweetSubmitButton.disabled = true;
  try {
    await createTweet(content);
  } catch (error) {
    console.error("Error sending tweet:", error);
  } finally {
    // Restore the original button text
    tweetSubmitButton.innerHTML = "Tweet";
    tweetSubmitButton.disabled = false;
  }
}

/*****************************************/
/* Detect the MetaMask Ethereum provider */
/*****************************************/

function initializeApp(provider) {
  if (provider !== window.ethereum) {
    throw new Error(
      "App not initialized. Do you have multiple wallets installed?"
    );
  }

  // --- Expected flow
  const { connectWalletBtn, tweetFormForm, ethereumButton, userAddress } =
    getHtmlElements();

  console.log("llegamos aqui");

  // pingContract();

  //   // Connect Wallet
  //   connectWalletBtn.addEventListener("click", onConnectWalletClicked);
  //   // Submit form
  //   tweetFormForm.addEventListener("submit", onTweetFormSubmitted);

  //   // Chain-change listener
  //   const chainId = await window.ethereum.request({ method: "eth_chainId" });
  //   console.log("Chan ID: ", chainId);
  //   window.ethereum.on("chainChanged", handleChainChanged);

  //   window.ethereum
  //     .request({ method: "eth_accounts" })
  //     .then((_accounts) => handleAccountsChanged(_accounts, userAddress))
  //     .catch((err) => {
  //       console.error(err);
  //     });

  //   ethereumButton.addEventListener("click", onEthBtnClicked);
  //   window.ethereum.on("accountsChanged", handleAccountsChanged);
}

/**********************************************************/
/* Handle chain (network) and chainChanged (per EIP-1193) */
/**********************************************************/

function handleChainChanged(chainId) {
  window.location.reload();
}

/***********************************************************/
/* Handle user accounts and accountsChanged (per EIP-1193) */
/***********************************************************/

function handleAccountsChanged(accounts, userAddress) {
  let currentAccount = null;

  if (accounts.length === 0) {
    console.log("Please connect to MetaMask.");
  } else if (accounts[0] !== currentAccount) {
    currentAccount = accounts[0];
    userAddress.innerHTML = currentAccount;
  }
}

/*********************************************/
/* Access the user's accounts (per EIP-1102) */
/*********************************************/

async function getAccount() {
  const accounts = await window.ethereum
    .request({ method: "eth_requestAccounts" })
    .catch((err) => {
      if (err.code === 4001) {
        console.log("Please connect to MetaMask.");
      } else {
        console.error(err);
      }
    });
  const account = accounts[0];
  userAddress.innerHTML = account;
}
